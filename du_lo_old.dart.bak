import 'dart:io';


class DataModel {
  final String date;
  final int de;
  final List<int> others;

  DataModel({
    required this.date,
    required this.de,
    required this.others,
  });
}

class RoiStat {
  int hit = 0;
  int total = 0;
  int profit = 0;

  double get winrate => total == 0 ? 0 : hit / total * 100;
  double get roiPerTurn => total == 0 ? 0 : profit / total;
}

/// Strategy ƒë·ªÉ t·∫°o c·∫∑p 2 s·ªë t·ª´ de
class PairStrategy {
  final String name;
  final List<int> Function(int de) generatePairs;

  PairStrategy({required this.name, required this.generatePairs});
}

/// K·∫øt qu·∫£ backtest cho m·ªôt strategy
class BacktestResult {
  final String strategyName;
  final int totalDays;
  final int hits;
  final int misses;
  final double winrate;
  final int profit;
  final double roi;
  final int maxWinStreak;
  final int maxLoseStreak;
  final int currentWinStreak;
  final int currentLoseStreak;
  final List<bool> history;
  final double variance;

  BacktestResult({
    required this.strategyName,
    required this.totalDays,
    required this.hits,
    required this.misses,
    required this.winrate,
    required this.profit,
    required this.roi,
    required this.maxWinStreak,
    required this.maxLoseStreak,
    required this.currentWinStreak,
    required this.currentLoseStreak,
    required this.history,
    required this.variance,
  });

  double get riskScore => maxLoseStreak * 10 + variance;
}

Future<List<DataModel>> loadDataModels(String path) async {
  final lines = await File(path).readAsLines();
  lines.removeAt(0);

  return lines.map((line) {
    final parts = line.split(',');
    return DataModel(
      date: parts[0],
      de: int.parse(parts[1]),
      others: parts.sublist(2).map(int.parse).toList(),
    );
  }).toList();
}

List<PairStrategy> createStrategies() {
  return [
    PairStrategy(
      name: 'Gi·ªØ nguy√™n DE',
      generatePairs: (de) => [de],
    ),
    PairStrategy(
      name: 'T√°ch 2 ch·ªØ s·ªë DE',
      generatePairs: (de) {
        if (de < 10) return [de];
        final digit1 = de ~/ 10;
        final digit2 = de % 10;
        return [digit1, digit2];
      },
    ),
    PairStrategy(
      name: 'DE + 2 ch·ªØ s·ªë',
      generatePairs: (de) {
        if (de < 10) return [de];
        final digit1 = de ~/ 10;
        final digit2 = de % 10;
        final pairs = <int>{de, digit1, digit2};
        if (digit1 != digit2) {
          pairs.add(digit2 * 10 + digit1);
        }
        return pairs.toList();
      },
    ),
    PairStrategy(
      name: 'Ch·ªâ 2 ch·ªØ s·ªë (b·ªè DE)',
      generatePairs: (de) {
        if (de < 10) return [];
        final digit1 = de ~/ 10;
        final digit2 = de % 10;
        return [digit1, digit2];
      },
    ),
    PairStrategy(
      name: 'DE + ƒë·∫£o ng∆∞·ª£c',
      generatePairs: (de) {
        if (de < 10) return [de];
        final digit1 = de ~/ 10;
        final digit2 = de % 10;
        if (digit1 == digit2) return [de];
        return [de, digit2 * 10 + digit1];
      },
    ),
  ];
}

BacktestResult backtestStrategy(
  PairStrategy strategy,
  List<DataModel> sortedData,
) {
  final history = <bool>[];
  int hits = 0;
  int misses = 0;
  int profit = 0;
  int currentWinStreak = 0;
  int currentLoseStreak = 0;
  int maxWinStreak = 0;
  int maxLoseStreak = 0;
  
  final dailyProfits = <int>[];
  
  const int stakePerNumber = 1;
  const int payoutPerHit = 70;
  
  for (int i = 0; i < sortedData.length - 1; i++) {
    final today = sortedData[i];
    final tomorrow = sortedData[i + 1];
    
    final pairs = strategy.generatePairs(today.de);
    
    if (pairs.isEmpty) {
      continue;
    }
    
    final tomorrowOthersSet = tomorrow.others.toSet();
    bool hasHit = false;
    int hitCount = 0;
    
    for (final pair in pairs) {
      if (tomorrowOthersSet.contains(pair)) {
        hasHit = true;
        hitCount++;
      }
    }
    
    final totalStake = pairs.length * stakePerNumber;
    final totalPayout = hitCount * payoutPerHit;
    final dayProfit = totalPayout - totalStake;
    
    dailyProfits.add(dayProfit);
    
    if (hasHit) {
      hits++;
      currentWinStreak++;
      currentLoseStreak = 0;
      if (currentWinStreak > maxWinStreak) {
        maxWinStreak = currentWinStreak;
      }
      history.add(true);
    } else {
      misses++;
      currentLoseStreak++;
      currentWinStreak = 0;
      if (currentLoseStreak > maxLoseStreak) {
        maxLoseStreak = currentLoseStreak;
      }
      history.add(false);
    }
    
    profit += dayProfit;
  }
  
  double variance = 0;
  if (dailyProfits.isNotEmpty) {
    final mean = dailyProfits.reduce((a, b) => a + b) / dailyProfits.length;
    final squaredDiffs = dailyProfits.map((p) => (p - mean) * (p - mean)).toList();
    variance = squaredDiffs.reduce((a, b) => a + b) / dailyProfits.length;
  }
  
  final totalDays = hits + misses;
  final winrate = totalDays > 0 ? (hits / totalDays * 100) : 0.0;
  final roi = totalDays > 0 ? (profit / totalDays) : 0.0;
  
  return BacktestResult(
    strategyName: strategy.name,
    totalDays: totalDays,
    hits: hits,
    misses: misses,
    winrate: winrate,
    profit: profit,
    roi: roi,
    maxWinStreak: maxWinStreak,
    maxLoseStreak: maxLoseStreak,
    currentWinStreak: currentWinStreak,
    currentLoseStreak: currentLoseStreak,
    history: history,
    variance: variance,
  );
}

Future<void> main() async {
  final data = await loadDataModels('data.csv');
  
  final dataWithDate = data
      .map((d) => (
            model: d,
            dateTime: DateTime.parse(d.date),
          ))
      .toList();
  dataWithDate.sort((a, b) => a.dateTime.compareTo(b.dateTime));
  final sortedData = dataWithDate.map((e) => e.model).toList();
  
  print('üìä BACKTEST CH·ªåN C·∫∂P 2 S·ªê T·ª™ DE NG√ÄY A ‚Üí KI·ªÇM TRA TRONG OTHERS NG√ÄY A+1');
  print('=' * 80);
  print('T·ªïng s·ªë ng√†y d·ªØ li·ªáu: ${sortedData.length}');
  print('S·ªë ng√†y c√≥ th·ªÉ backtest: ${sortedData.length - 1}\n');
  
  final strategies = createStrategies();
  
  final results = <BacktestResult>[];
  for (final strategy in strategies) {
    final result = backtestStrategy(strategy, sortedData);
    results.add(result);
  }
  
  results.sort((a, b) {
    final winrateCompare = b.winrate.compareTo(a.winrate);
    if (winrateCompare != 0) return winrateCompare;
    return a.riskScore.compareTo(b.riskScore);
  });
  
  print('üìà K·∫æT QU·∫¢ BACKTEST (S·∫Øp x·∫øp theo Winrate gi·∫£m d·∫ßn, Risk tƒÉng d·∫ßn):');
  print('=' * 80);
  print('');
  
  for (int i = 0; i < results.length; i++) {
    final r = results[i];
    print('${i + 1}. ${r.strategyName}');
    print('   ‚îú‚îÄ Winrate: ${r.winrate.toStringAsFixed(2)}% (${r.hits}/${r.totalDays})');
    print('   ‚îú‚îÄ ROI/l·∫ßn: ${r.roi.toStringAsFixed(2)} ƒëi·ªÉm');
    print('   ‚îú‚îÄ T·ªïng profit: ${r.profit} ƒëi·ªÉm');
    print('   ‚îú‚îÄ Max WIN streak: ${r.maxWinStreak}');
    print('   ‚îú‚îÄ Max LOSE streak: ${r.maxLoseStreak}');
    print('   ‚îú‚îÄ Hi·ªán t·∫°i: ${r.currentWinStreak > 0 ? "WIN ${r.currentWinStreak}" : "LOSE ${r.currentLoseStreak}"}');
    print('   ‚îú‚îÄ Variance: ${r.variance.toStringAsFixed(2)}');
    print('   ‚îî‚îÄ Risk Score: ${r.riskScore.toStringAsFixed(2)} (th·∫•p h∆°n = √≠t r·ªßi ro h∆°n)');
    print('');
  }
  
  final bestStrategy = results.first;
  print('üèÜ STRATEGY T·ªêT NH·∫§T: ${bestStrategy.strategyName}');
  print('   Winrate: ${bestStrategy.winrate.toStringAsFixed(2)}%');
  print('   Risk Score: ${bestStrategy.riskScore.toStringAsFixed(2)}');
  print('   ROI/l·∫ßn: ${bestStrategy.roi.toStringAsFixed(2)} ƒëi·ªÉm');
}
